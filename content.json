{"pages":[],"posts":[{"title":"軟體開發中的“無緒”","text":"無緒 (Cluelessness) 由 Martin Rinard 提出。他在演講時指出： 在開發和維護軟體系統時，應該避免讓開發人員深入了解系統。 因為人的大腦可以處理的資訊有限。若要建立一個日益變大的應用程式，就必須學習「如何讓每個開發人員在不了解整個應用程式的情況下，也能完成軟體開發」。 “無緒” 並不是一個貶義詞。它用來區別兩種層次的理解水平。 淺層理解：指對事物的了解程度僅限於掌握使用方法即可。 深層理解：指對掌握了事物背後的原則、規律、原理。 在日常生活中的“無緒”生活中我們通常只需要用到 淺層理解。例如，刷牙不需要知道化學式。不需要理解冰箱原理就可以冷凍食品。當然，也有一些人需要了解更深入的內容。像是冰箱的維修人員就要了解較深入的領域知識。但即便如此，維修人員所需要的知識仍屬於 淺層理解，因為他們也不需要了解事物背後的每個小細節和原理。 當然也可以學習每件事物背後的知識原理，但是必要性與 CP 值通常不大。因此大多數人在日常生活中只需要 淺層理解 就足夠了。 軟體開發中的“無緒”在軟體開發中，“無緒” 也表示大部分的時間中，開發人員只需要 淺層理解 就足以應付工作。這裡的 淺層理解 並不是指開發人員不需要懂得編寫程式。以下舉個例子來說明軟體開發中的 淺層理解 與 深層理解 之間的差異。 「電子商務網站」：某天 PM 告知下一個專案是「電子商務網站」。那麼，實作這個網站有兩種做法： 實作方法一：12345在專案初始階段： 我需要打開 HTTP 協定的文件，解析 HTTP 傳輸格式、研究如何實現 POST、GET 請求....等等。 此外還要閱讀 RFC 文件，並實現文件中的各項內容。 全部都搞定後才能開始打造「電子商務網站」。 實作方法二：12在專案初始階段，在作業系統中下載並安裝 Apache、PHP、MySQL， 設定妥當後即開始打造「電子商務網站」。 相信 實作方法二 才是大家熟悉開發的方式，因為現代軟體都是基於組件組裝出來的，沒有人需要獨自從頭到尾完成所有內容。在一個作業系統上安裝 Web 服務並開始編寫 HTML，對現在的開發人員來說是易如反掌。但事實上光是 Web 服務就已經複雜到極點，應該沒人敢說自己了解 Web 服務的所有內容。這一現象正是 淺層理解 的體現，讓開發人員在大部分的時間中，只需要掌握系統、框架、程式庫的使用方法，即可以將現成的組件應用到自己的應用程式，或是在組件上堆疊自己的應用程式。 設計原則中的“無緒”我們的目標是找到一種軟體開發的實踐方式：讓開發人員不用深入了解所有組件或者模組的實現原理，僅用最少的知識就可以很好地完成自己所需要的功能。這種開發方式被稱為「選擇性無緒(selective cluelessness)」。 選擇性無緒 的思維，正好符合軟體設計原則的 緊湊性。當一個程式具有緊湊性時，即具有「易於理解、使用、組合」等特性。這些特性讓使用者幾乎可以不用閱讀文件，即可自然而然的使用這些程式。但是要注意的是，緊湊性並不等同於「容易學習」。 以下提供一個緊湊與不緊湊的範例： 原生的 JavaScript 的 Date 物件是不緊湊的：123456789// 時間格式轉換var now = new Date(); var year = now.getFullYear(); var month = (\"0\" + (now.getMonth() + 1)).slice(-2); var day = (\"0\" + (now.getDate() + 1)).slice(-2); var hour = (\"0\" + (now.getHours() )).slice(-2); var minute = (\"0\" + now.getMinutes() ).slice(-2); var second = (\"0\" + now.getSeconds() ).slice(-2); year + '/' + month + '/' + day + ' ' + hour + ':' + minute+ ':' + second; moment.js 的 moment 物件是緊湊的：12// 時間格式轉換moment().format('YYYY/MM/DD HH:mm:ss'); 若程式設計得當，維護人員就可以使用 淺層理解 來學習你的程式。若程式設計得不夠緊湊，維護人員往往需要將頭腦切換成 深層理解 的模式來探索你的程式碼，並學習是如何運作的。 因此編寫程式的過程中，應該時時刻刻想著如何讓你的程式變得 “無緒”，讓使用者可以用最少的力氣學習你的程式。這樣的設計思維適用於「函式、類別、模組、類別庫、架構、框架以及系統」的情境。也就是 Martin Rinard 所說的： 軟體設計要盡可能做到 “無緒”。讓開發人員可以在對系統很少了解的前提下，仍然可以完成開發的工作。 延伸閱讀 自學時應該看破“無緒” 文章內容整理自以下書籍並加以歸納與簡化： 軟件框架設計的藝術(Practical API Design) UNIX編程藝術","link":"/blog/Cluelessness/"},{"title":"CodeIgniter 3 框架擴展套件：HMVC","text":"Hierarchical(階層式的)-Model-View-Controller（HMVC）模式，也可以叫做 Layered MVC。 為什麼需要 HMVC單層 MVC 的限制原 MVC 架構中只有單層 MVC，單層 MVC 的設計本身沒問題，但隨著系統功能逐漸變多變複雜時，程式碼卻只能塞進單層 MVC 裡面，程式碼很快就會變得巨大、縱錯複雜、互相耦合、難以維護。試想一下，一個 Controller 內有 7、8 千行程式碼會容易維護嗎。 原 CodeIgniter MVC 架構(單層 MVC)示意圖： 1234567891011121314151617application |- controllers |- controllersA.php |- controllersB.php |- ...(所有 Controller 都只能放在同一層） |- models |- models1.php |- models2.php |- ...(所有 Model 都只能放在同一層） |- views |- views1 |- index.php |- footer.php |- ... |- views2 |- index.php |- footer.php HMVC 帶來的解決方案：擴展 MVC 架構，讓 MVC 底下可以再擴充一層或多層子 MVC，讓單層 MVC 變成階層式 MVC，而這些擴充的 MVC，又稱作為模組、模塊(Modules)。使用模組好處是： 使每個功能都可以獨立出來 因模組變得獨立，降低各個功能模組之間的耦合性 提高程式碼複用性 每個模組都有自己的 MVC 結構 HMVC 架構示意圖： CodeIgniter HMVC 擴展模組後，其結構(階層式 MVC)如下：12345678910111213141516171819202122232425262728293031application |- modules |- moduleA |- controllers |- controllers.php |- models |- models.php |- views |- index.php |- footer.php |- ... |- modules (模組 A 底下還可以有子模組...） |- controllers |- moduleB |- controllers |- controllers.php |- models |- models.php |- views |- index.php |- footer.php |- ... |- modules (模組 B 底下還可以有子模組...） |- controllers |- .... |- controllers |- ... |- models |- ... |- views |- ... 真實使用情境：某系統中有個 表單管理 的功能如下圖，但是 表單管理 底下其實有多個功能，這些功能都屬於 表單管理 的範疇: 只有單層 MVC 架構的情況下，這些功能的程式碼都必須寫在同一個 Controller 裡面。因此 單層 Controller 會在很短的時間內便得龐大又複雜。 在 HMVC 架構中，則可以把這些功能全部拆分成 表單管理 底下的模組。這麼做 減輕了單層 Controller 對每個功能模組的耦合。拆出去的模組也變得高內聚，且模組的功能變得更容易複用。 表單管理 HMVC 模組結構 不斷地抽象、封裝HMVC 可以說是物件導向程式設計的體現。 一個良好的物件導向系統，會隨著程式碼的複雜度上升與變化增加，不斷的進行抽象、封裝。 抽象是將一系列相關的程式碼做歸納，目的是降低人類的認知超載。而封裝是抽象過程中的一種技術，且物件導向開發傾封裝複雜的過程，以便重複利用。 如果不做抽象會怎樣？嘗試一下下面的範例: 1234567891011121314151617181920212223242526272829303132333435// If url is an object, simulate pre-1.5 signatureif (typeof url === \"object\") { options = url; url = undefined;}// Force options to be an objectoptions = options || {};var // Create the final options objects = jQuery.ajaxSetup({}, options),// Callbacks contextcallbackContext = s.context || s,var // Create the final options objects = jQuery.ajaxSetup({}, options),// Callbacks contextcallbackContext = s.context || s,// Context for global events// It's the callbackContext if one was provided in the options// and if it's a DOM node or a jQuery collectionglobalEventContext = callbackContext !== s &amp;&amp;( callbackContext.nodeType || callbackContext instanceof jQuery ) ? jQuery(callbackContext) : jQuery.event,// Deferredsdeferred = jQuery.Deferred(),completeDeferred = jQuery.Callbacks(\"once memory\"),// Status-dependent callbacksstatusCode = s.statusCode || {},// ifModified keyifModifiedKey,// Headers (they are sent all at once)requestHeaders = {},/** * ajax 全長有 380 行程式碼，故省略。 **/ 上面這段程式碼都是「實作」非同步連線功能的程式碼。而 jQuery 將這段程式碼抽象成大家熟悉的 $.ajax。如果每次使用非同步連線功能都要寫 380 行程式碼，那真的會瘋掉。 HMVC 除了封裝以外，又讓模組享有 MVC 的功能HMVC 不只是單純的進行抽象，也讓每個模組享有 MVC 架構的功能！ 參考資源 讓Codeigniter支持HMVC架構 什麼是 HMVC HMVC Wiki wiredesignz-codeigniter-hmvc","link":"/blog/codeigniter_3_hmvc/"},{"title":"自學時應該看破“無緒”","text":"上一篇文章 軟體開發中的“無緒” 介紹了無緒的概念，講的是軟體開發的過程中，應該思考如何讓程式的使用者可以無緒。 這篇則是延伸無緒的概念，講解開發人員自學的時候，如何找出新技術背後的知識，並且堆疊知識。 正文開始軟體技術的發展都是基於無緒的，每個無緒的新技術中總會埋藏一些知識。如果每一項新技術都是新的知識，那我們就只能把每項技術都試過一遍，才能將技術轉化成知識。這樣的學習方法導致我們沒辦法用過去的經驗來學習新技術，導致較低的學習效率。 幸好人類的大腦有傑出的 抽象能力，也就是我們常說的推理、歸納、一般化、舉一反三等等，意思都差不多。 學習一項新技術時，試著將技術抽象一下，排除不相關的細節，找出技術背後的知識。 通常可以透過下列三個問題來找出技術背後的知識： 技術的本質是什麼？ 想解決什麼問題？ 前置知識是什麼？ 挖掘技術背後的知識與思維知識總是會和無關緊要的細節糾纏在一起，當知識和細節糾纏在一起時，知識只能被應用在狹窄的情境。當你從技術歸納出背後的知識時，會發現有許多技術的知識本質是相同的。這幫助你在學習新技術時，能夠看透新技術無緒的表面，推理出新技術內部的原理。理解內部的原理後，新技術也只剩下外面一層皮，學習速度自然加快許多。 學習新知識時也要盡量學習作者的思維。去了解作者為什麼要這樣設計，以及學習作者如何設計；學會這些思維層面的知識，會幫助「未來的你」進行思考。遇到新技術或問題時，會有更多推測與決策的能力。 重視知識的本質對一個開發人員來說非常重要，海量的新技術總是不斷的成長，讓很多人感嘆跟不上新技術。新技術數量的不斷成長的對策，就是 抓住不變的知識。大量的新技術其實只是一層皮，支撐在背後的技術跟知識都是數十年來不變的東西。演算法及資料結構不會過時；程式設計理論1不會過時；開發論及方法論2不會過時；良好的編寫程式習慣3永遠不會過時；分析問題與決策4的能力不會過時… 因此在學習新技術的同時，也別忘了閱讀軟體界大神們的 經典書籍 以及上述 不變的知識。因為這些和思維相關的知識，能夠幫助我們進行更好的決策、學習、判斷與知識堆疊。 文章內容整理自以下書籍並加以歸納與簡化： 軟件框架設計的藝術(Practical API Design) 暗時間 註腳1.程式設計理論: OOP、OOAD ↩2.開發論及方法論: CI/CD、DDD、Clean Architecture、BBD、TDD、ATDD、Specification By Example ↩3.良好的編寫程式習慣: Clean Code、易讀程式之美學、單元測試 ↩4.分析問題與決策: 重構、SOLID 原則、Design Pattern ↩","link":"/blog/cluelessness_in_self_learning/"},{"title":"重構的定義與目的","text":"重構定義： 在不改變軟體外部行為的前提下，改變其內部結構，使其更容易理解且易於修改。 目的：重構的主要目的就是為了提升程式碼品質、提升程式碼的可讀性，以及為了日後有新需求的變化時，程式碼可以 更容易修改或是擴充（提高可維護性）。 優點：1. 改進程式碼的設計：消除重覆的程式碼，每個小功能被歸責到適當的物件中，讓程式碼的職責更清楚就會更容易維護。將雜亂無序的程式碼，重構成一連串的 精心設計 的流程，讓程式碼更容易擴充。 2. 程式碼更容易被理解：重構簡單的講，就是整理程式碼，可以透過 Clean Code 的規範 來整理程式碼，提升可讀性。想想程式碼過一段時間後的第二個讀者，而且這個人常常是你自己。 3. Debug 更容易：重構的過程中，會透過單一職責原則，依照程式碼的工作責任將程式碼整理至責任相同的類別中。有責任清楚的物件，就能更快釐清問題點，除錯速度自然能夠提升。 什麼時候可以開始重構？事實上，重構並不是一項需要額外撥出時間來進行的工作，重構應該是在你的開發過程中持續在發生的事情。 重構的活動，最理想的情況，就是透過持續不斷的整理，掃除那些有礙程式可讀性及可維護性的程式碼，讓程式碼持續盡可能地保持在一定健康的狀態。 既然重構是一個持續進行的活動，但又不是特意安排、特別撥出時間來做的工作，那麼，在什麼樣明確的時間點，應該觸發重構的進行呢？基本上，重構的活動應該伴隨著我們一般開發過程中的主要活動來進行。這些主要活動包括了：增加新功能、修正錯誤、以及程式碼審查的時候，還有三次法則。 三次法則：同樣的事做三次，犯了 Don’t Repeat Yourself 原則，表示重複的邏輯該被重構成唯一且適當的物件或函式了。 新增功能時重構： 當我們試著增加新功能時，便有可能發現舊有的程式碼可以進行一些調整，而達成了必須重構所想要達成的目的。 但如果你在增加功能的時候，發現原設計就足以優雅地讓你將新功能擴充上去，那麼，這意謂著，還不太需要做什麼重構。 除錯時重構：除錯的時候，你不僅會接觸到舊有的程式碼，而且，你通常得搞懂它真正的運作邏輯，當你真的懂了之後，就會知道如何用更清晰、簡潔的方式來改寫這段程式碼。 總結：很多架構良好的程式，並不是一開始就規畫出來的，而是每天不斷不斷的重構、改進。重構也不用刻意安排時間去做，在每次做新功能或修改功能時就順便做重構整理，如果可以也一起加入 Unit Test。童子軍有一條軍規是 讓營地比你來時更乾淨，套用在寫程式上，就是在每次的 checkin ，程式碼應該都是要比 checkout 時更乾淨簡潔。","link":"/blog/refactoring_definition_and_purpose/"},{"title":"淺談物件導向 SOLID 原則對工程師的好處與如何影響能力","text":"前言為了感謝部落格一直以來都有人在閱讀，讓我一直有經營下去的動力。所以想寫一個系列 學習 SOLID 原則 2 年後的心得文章。這心得文章包含自己使用 SOLID 兩年的總結，並且以自己的理解簡化 SOLID 原則，希望幫助新手工程師縮短「SOLID 原則是文字天書」的時間。 從第一次接觸 物件導向 SOLID 原則 至今已經兩年了，一開始覺得「SOLID 原則是文字天書」，到現在 Coding 時常融入 SOLID 的思想來「設計」程式。 所以 SOLID 原則到底是什麼？ SOLID 原則是物件導向「設計層面」的思維與定律。 大學時期程式設計課程中所學的物件導向，其實只是在介紹程式語言有提供 物件導向的哪些特性，卻 從未有人教導如何透過物件導向的特性撰寫程式碼，甚至沒人告訴你為什麼要用物件導向開發程式。 然而 SOLID 原則就是物件導向開發的指導方針，若以多個角度來看這些原則，會發現 SOLID 已經指出 物件導向的優點 以及 程序式程式碼隱晦的缺點。但這不代表物件導向沒有缺點，要是沒有妥善運用 SOLID 原則的話，物件導向對專案的傷害絕對不比 程序式程式碼 低！但這留給後續的文章來解釋，首先來看看 SOLID 的好處與重要性。 SOLID 原則對專案的好處？SOLID 原則對專案的影響很大，當專案一點一滴的導入 SOLID 原則的程式碼，不少複雜的程式碼慢慢被簡化，被簡化的程式碼可以降低複雜度，讀懂程式碼的時間從原本需要花 20 分鐘閱讀，到只需要花費 2 分鐘閱讀。縮短閱讀時間對專案來說是一件好事，一般來說工程師「閱讀程式碼」的時間常常大於「新增/修改程式碼」的時間，畢竟要先讀懂才能動手嘛，因此 縮短閱讀程式碼時間 等於 縮短「新增/修改程式碼」程式碼的時間。 優點：降低程式碼複雜度 =&gt; 縮短閱讀程式碼的時間 =&gt; 減少維護專案程式碼的時間 你可能會覺得，為什麼 SOLID 原則可以降低程式碼的複雜度？因為 物件導向本身的目的就是管理「程式碼複雜度」，這也是為什麼這麼多人推崇使用物件導向開發的原因，然而 SOLID 原則是教導工程師應該如何透過 物件導向的特性 來管理程式碼的複雜度。 SOLID 原則對工程師的好處？由上述可知 SOLID 原則可以降低程式碼的複雜度，這是第一個好處，因為降低工程師開發過程的痛苦值！（應該沒人想一直面對醜陋複雜的程式碼） 再來的好處可多的呢！為什麼這麼說呢？SOLID 原則是踏入資深工程師階段的必學觀念。大部分 軟體開發的進階觀念，都建構在良好的物件導向程式碼之上。要是沒辦法妥善運用物件導向，就沒辦法運用軟體開發的進階觀念/技巧。 》這相當重要，若工程師沒有能力學習進階觀念，很可能就會一直停留在碼農階段。 但是學會 SOLID 原則之後呢？以下列出 SOLID 未來的應用，下列被提及的每個議題都是 進階物件導向重要的基石，很值得花時間投資： 1. 單元測試 用程式碼撰寫測試程式，取代手動測試。 替專案提供回歸測試，時時刻刻執行單元測試，檢查有沒有人改壞程式碼。 符合 SOLID 原則的程式碼可以輕易導入單元測試。 2. 重構 在不改變程式碼外部行為的前提下，修改程式碼內部的結構，提升可讀性與擴充性。 重構必然會搭配測試，避免改壞程式碼。 低階重構：把爛 Code 重構成符合物件導向 SOLID 原則（敏捷開發）。 中階重構：把 SOLID 重構成設計模式（敏捷開發）。 高階重構：把 SOLID 重構成軟體架構（敏捷開發）。 3. 設計模式 進階物件導向應用 學習 物件與物件之間常見的組合模式。用來管理程式碼的複雜度，或解決開發系統中的各種常見問題。 學過設計模式，在寫程式或閱讀程式的時候，會用更高一層的視角去思考。 最後會培養出根深蒂固的抽象觀念。 》但這些議題卻又基於 SOLID 原則之上 因為 SOLID 原則幫助專案建立一個乾淨、穩定、良好的物件導向程式碼，讓這些物件導向程式碼可以引入更進階的概念/技巧。 這裏引用 Uncle Bob 在 物件導向原則、設計模式與C#實踐 這本書說過的話： 我的書裡所教的觀念與技巧，都只對乾淨的 Code 有效益。如果你的程式碼還很雜亂，請先學會怎麼整理程式碼。Uncle Bob（現代軟體界大神） 然而 這本書也是 SOLID 的原點。軟體開發的觀念幾乎就圍繞在上述幾個議題在發展，因此有沒有學會上述議題，基本上就是碼農跟中高階工程師的分水嶺。如果持續努力學習這些議題，馬上就能 凸顯跟大部分工程師的差異性，面試時可以談的條件也會變多。 我的學習路線如下：SOLID &gt; 重構 + 單元測試 &gt; 設計模式 &gt; 測試驅動開發(TDD) &gt; 行為驅動開發(BDD) &gt; 領域驅動開發(DDD) 但是真實的學習過程其實經常交叉學習，不一定是先學完前者才往下學習下一個。因為這些議題都是環環相扣，常常可以在後面的議題學習到前面議題的進階用法。 結尾：以往學習 SOLID 原則時，大部分文章都專注在每個原則的介紹與範例，卻幾乎沒人提及 SOLID 原則與物件導向之間的關係，以及 wSOLID 原則日後的發展為何？因此我想在講解 SOLID 每個原則之前，先花篇幅琢磨在兩個問題上。希望也能替其他人解開疑問。 接下來也將會陸續推出講解 SOLID 每個原則的文章出現，沒意外的話下次 PO 文是探討 單一職責原則。 此文章也會同步到：我的部落格 系列文章： 淺談物件導向 SOLID 原則對工程師的好處與如何影響能力 再談 SOLID 原則，Why SOLID? 物件導向設計原則：單一職責原則，定義、解析與實踐 物件導向設計原則：開放封閉原則，定義、解析與實踐","link":"/blog/why_SOLID_principles_matter_to_you/"},{"title":"再談 SOLID 原則，Why SOLID?","text":"Why SOLID? 在前一篇文章中介紹 SOLID 對一個工程師的影響，這裡再稍微補充一下為什麼軟體開發會需要 SOLID 原則？ 軟體複雜的本質專案經常會歷經「商業邏輯調整」和「快速且多變的需求」，這都不是開發環節所能控制的，但是一個專案會「遇到困難」常常是因為 糟糕的程式設計 和其他技術層面導致。 其中 糟糕的程式設計 又可分成三大因素： 程式碼變更 Bug 修復 複雜度控制 在添加功能前應該 閱讀代碼並細心設計，但實際上更常發生的是，開發者選擇直接在程式碼上面堆疊新的程式碼。新舊版本 和 意圖不同 的程式碼錯綜複雜之下，會讓專案難以在不引發連鎖反應的情況下增加功能。最後新的功能引入 Bug，從而導致另一個 Bug，然後一個接著一個，這樣的事情不斷發生。 在 沒有做過可擴展性設計的程式碼 上進行擴展功能，常常是火上加油！那為什麼不把程式「設計」成可擴展就好了呢？ 開發者知識普遍不足一個充滿外行人的產業 開發者們來自不同的背景，且有大量不同的方式去解決問題，但是一個開發者應該具備什麼樣的知識體系，卻沒有一個廣泛的共識。 更不幸的是，許多開發者在學校裡面學到的知識是過時的，學校提供的程式設計課程並未給學生做好準備。這些課程通常只關注程式語言的功能，但是 … 掌握一門程式語言並不能使你成為軟體開發者，正如掌握一門自然語言並不能使你成為作家 學校所教的知識，並不是大部分軟體開發者的工作內容。開發者也許能編寫一個可運行的程式碼，但若要回頭去擴展程式碼卻常常是艱難且冒險的。 軟體開發過程中，開發者需要做出無數個選擇，加上每個開發者用不同的方法解決問題，助長了難以維護、難以擴展的程式碼。最終讓 系統設計的思想溝通 變得困難。 工程師必須花費大量時間閱讀程式碼。 不論是開發者還是管理者都需要對 軟體複雜的本質 做管理。為了編寫出更容易應對變化的程式碼，我們必須填補基礎認知方面的空白。 導入設計原則若有一些原則可以指導工程師在 一定的情況下理解每個選擇的所得所失 並做出最佳權衡，則可以統一工程師解決問題的方法，降低 系統設計思想溝通 的困難度。 Uncle Bob 花費多年整理了許多開發人員、研究人員的思想和著作結晶，提出了 5 個設計原則： 單一職責原則（The Single Responsibility Principle, 簡稱 SRP) 開放-封閉原則 (The Open-Close Principle, 簡稱 OCP) 里氏替換原則 (The Liskov Substitution Principle, 簡稱 LSP) 依賴倒置原則 (The Dependency Inversion Principle, 簡稱 DIP) 接口隔離原則 (Interface Segregation Principle, 簡稱 ISP) SOLID 原則目的是讓程式碼在面對改變時，能有一套策略來應對。 SOLID 原則指導開發者們該 如何將函式和資料結構安排到類別中，以及這些 類別該如何互相關聯。 遵循 SOLID 原則的程式碼具有以下特性： 能夠容忍變化 容易擴展新邏輯 容易理解 容易複用 雖然 SOLID 原則是 物件導向 的設計原則，但事實上這些原則與思維一直存在軟體工程中。因此 SOLID 原則的思維可以延伸套用至非物件導向語言、系統架構等等領域。 順帶一提，SOLID 原則並沒有順序關係，單純是 Michael Feathers(1 發了電子郵件告訴 Uncle Bob 可以用 SOLID 這個詞彙將 5 個原則串起來變成口訣方便記憶。所以在學習 SOLID 原則的過程中，可以不用按照順序學習。 備註： Michael Feathers 是 Working Effectively with Legacy Code 的作者，也是一本開發者必讀經典書籍。 此文章也會同步到：我的部落格 系列文章： 淺談物件導向 SOLID 原則對工程師的好處與如何影響能力 再談 SOLID 原則，Why SOLID? 物件導向設計原則：單一職責原則，定義、解析與實踐 物件導向設計原則：開放封閉原則，定義、解析與實踐","link":"/blog/why_we_need_SOLID_principles/"},{"title":"Git Commit Message 這樣寫會更好，替專案引入規範與範例","text":"其實寫 Commit Message 有時候跟寫程式註解還蠻像的，最好可以寫下「為什麼」你要作這樣的異動，而不是單單只記錄下你做了「什麼」異動， Commit Message 最好兼俱 Why 及 What，讓日後進行維護人員更快進入狀況。 Commit Message 這樣寫會更好： 做 issue 的時候，不應該一次 Commit 所有異動！應該獨立 Commit 每個不同意義的異動，這樣 commit 訊息才會跟異動的程式碼有關聯。 每次 Commit 都是針對異動的檔案做說明：Why &amp; What。這樣的 Commit Message 能讓日後的維護人員更快進入狀況 每次 Commit 都加上 issue 編號，方便追蹤相關的程式異動原因。 若 Commit Message 寫得妥當，在閱讀追蹤程式碼的意圖會相當容易。如果只把 Git 當作版本控制，隨意撰寫 Commit Message 就太可惜了！ 不能只把 Git 當作程式碼的 FTP，這樣太可惜了，要把 Git 當作歷史查閱的工具才拿發揮 Git 的功能。 好與不好的真實案例用一個小插曲證實 Commit 訊息的重要性上面 PPT 是我在工作中遇到的兩個案例，範例中包含「好的 Commit Message」與「不良的 Commit Message」。在範例中可見： 良好的 Commit Message: 如何在「一年後」讓維護人員進入狀況 不良的 Commit Message: 如何在「一個月內」讓維護人員找不出程式異動的原因。 Commit Message 之規範在撰寫 Git 與 SVN 等版本控制軟體 Commit Message 時，可以參照國外 AngularJS 團隊的規範： AngularJS Git Commit Message Conventions 以下為這套訊息規範的展示與說明：Commit Message 規範範例：Commit Message 規範範例解析： Commit Message 規範組成：12345678910111213Header: &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; - type: 代表 commit 的類別：feat, fix, docs, style, refactor, test, chore，必要欄位。 - scope 代表 commit 影響的範圍，例如資料庫、控制層、模板層等等，視專案不同而不同，為可選欄位。 - subject 代表此 commit 的簡短描述，不要超過 50 個字元，結尾不要加句號，為必要欄位。Body: 72-character wrapped. This should answer: * Body 部份是對本次 Commit 的詳細描述，可以分成多行，每一行不要超過 72 個字元。 * 說明程式碼變動的項目與原因，還有與先前行為的對比。Footer: - 填寫任務編號（如果有的話）. - BREAKING CHANGE（可忽略），記錄不兼容的變動， 以 BREAKING CHANGE: 開頭，後面是對變動的描述、以及變動原因和遷移方法。 type: subject 是簡述不要超過 50 個字元 type 只允許使用以下類別： feat: 新增/修改功能 (feature)。 fix: 修補 bug (bug fix)。 docs: 文件 (documentation)。 style: 格式 (不影響程式碼運行的變動 white-space, formatting, missing semi colons, etc)。 refactor: 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。 perf: 改善效能 (A code change that improves performance)。 test: 增加測試 (when adding missing tests)。 chore: 建構程序或輔助工具的變動 (maintain)。 revert: 撤銷回覆先前的 commit 例如：revert: type(scope): subject (回覆版本：xxxx)。 Type 是用來告訴進行 Code Review 的人應該以什麼態度來檢視 Commit 內容。例如： 看到 Type 為 fix，進行 Code Review 的人就可以用「觀察 Commit 如何解決錯誤」的角度來閱讀程式碼。 若是 refactor，則可以放輕鬆閱讀程式碼如何被重構，因為重構的本質是不會影響既有的功能。 利用不同的 Type 來決定進行 Code Review 檢視的角度，可以提升 Code Review 的速度。因此開發團隊應該要對這些 Type 的使用時機有一致的認同。 Commit 訊息範例範例 fix：123456789101112131415fix: 自訂表單新增/編輯頁面，修正離開頁面提醒邏輯問題：1. 原程式碼進入新增頁面後，沒做任何動作之下，離開頁面會跳提醒2. 原程式碼從新增/編輯頁面回到上一頁後（表單列表頁面），離開頁面會跳提醒原因：1. 新增頁面時，頁面自動建立空白題組會調用 sort_item，造成初始化 unload 事件處理器。2. 回到上一頁後，就不需要監聽 unload 事件，應該把 unload 事件取消。調整項目：1. 初始化 unload 事件處理器：排除新增表單時，頁面自動建立空白題組調用 sort_item 的情境2. 回到上一頁後，復原表單被異動狀態且清除 unload 事件處理器issue #1335 12345678910111213fix: 意見反應，信件看不到圖片問題問題：1. 客戶反應：意見反應的信件都看不到圖片。原因：1. 目前程式碼都會要求先登入後才可查看使用者上傳的檔案， 造成在信件上會看不見圖片的問題。調整項目：1. File.php，經討論後，開放讓意見反應頁面上傳的檔案，不用登入就可以查看/下載。issue #1229 範例 feat:1234567891011121314feat: message 信件通知功能因應新需求做調整： 通知和 message 都要寄發每日信件， 通知和 message 都用放在同一封信裡面就好， 不然信件太多可能也不會有人想去看。調整項目：1. mail_template.php，新增 message 區塊。2. Send_today_notify_mail.php，新增 取得每日 Message 邏輯。3. Message_model_api.php，新增 $where 參數，以便取得每日訊息。4. Message_api.php、Message_group_user_model_api.php，新增 **取得訊息使用者** 邏輯，以便撈取每日訊息。issue #863 123456789101112feat: 表單統計，多顯示計畫名稱欄位因應需求做調整：1. 列表資訊多加「計畫名稱」欄位，以利後續匯出資料處理。調整項目：1. Assessment_form.php，匯出表單統計時，新增訓練計畫名欄位。2. customize.php，表單統計查詢時，多顯示訓練計畫名欄位。3. Complex_assessment_form_api.php、Complex_assessment_form_model_api.php： - 取得表單統計資料時，多取得計畫名稱。issue #1200 範例 chore:12345chore: 更新 testing 環境更新 ci-phpunit-test 套件 0.16 =&gt; 0.17for Request GET 帶參數功能。 123456789101112131415chore:調整單元測試環境調整項目：1. MX/Modules將客製化 Testing 的邏輯移除，否則在測試環境中無法正確存取檔案。2. 加入 tests/unit 與 tests/integration 目錄，並將測試檔案移至合宜的位置。3. AdminTestCase.php，繼承 TestCase，實作登入邏輯、setUp 與 tearDown，供其他測試案例繼承使用。4. Bootstrap.php，引入 AdminTestCase.php 共測試案例繼承用。5. Login.php，因測試案例中不能有 header 的設定，更動系統登入邏輯，在測試環境中改用 redirect 轉址。6. phpunit.xml，取消嚴謹宣告覆蓋模式，避免造成測試不通過（若需知道你的測試案例覆蓋了哪些類別或邏輯，可自行打開）。## 備註： unit 與 integration 目錄分別為「單元測試目錄」與「整合測試目錄」，單元測試目錄負責測試 Api 與 Model，整合測試目錄則負責測試 Controller。issue #709 範例 style:123456789101112style: message 頁面，對 Component 做 Beautifier經 IE 瀏覽器測試後發現 Component 裡面仍然夾帶 ES6 語法，但是目前 Component 的程式碼都被壓縮成一行，為了日後修改程式方便，故先對所有被壓縮的程式碼做 Beautifier調整項目：1. 針對所有被壓縮的程式碼做 Beautifier2. 移除被註解的程式碼，原本被註解的程式碼應該是壓縮前的程式碼，但是經測試後發現這些被註解的程式碼都是舊 Code，故移除。issue #1219issue #1028 123style: 統一換行符號 CRLF to LF統一換行符號 123style: 調整 HTML 縮排issue #964 範例 refactor:1234567891011121314refactor: 重構取得「簽核流程種類名稱」邏輯原程式碼取得流程名稱的邏輯散落在多個檔案，為了讓未來新增/修改種類名稱時，不必到多個檔案找查程式，現在統一透過 Process::get_type_name($process_type) 方法，取得流程種類名稱。調整項目：1. Process.php，新增 get_type_name() 方法，供取得流程名稱稱用。2. workflow_type_name.php，此 View 檔案只是為了取得流程名稱，現在以 Process:: get_type_name() 取代，故刪除。3. Workflow_api.php，get_process_name() 方法是為了取得流程名稱，現在以 Process:: get_type_name() 取代，故刪除。4. 其他檔案：改用 Process:: get_type_name() 取得流程名稱。issue #1253 1234567refactor: 表單統計，語意化調整匯出表單時的表單答題資料，應該是以表單 $assessment_result 為基準做統計，故更改變數名稱 $user =&gt; $assessment_resultissue #1200 123456789101112131415161718refactor: 每日通知信件，重構程式結構考量將來可能會需要寄送多種資訊給使用者，故重構程式結構，讓未來擴充功能時比較方便。調整內容：1. Send_today_notify_mail： - 把取得「系統通知」邏輯搬移至 System_notify_handler.php - 把取得「站內訊息」邏輯搬移至 Message_handler.php - 引入 Pipeline，把取得各種系統資訊的邏輯注入進 Pipeline。 - 透過 Pipeline 取得每日通知信件內容，並建立信件 HTML2. Daily_email 介面： - 定義 每日信件處理器 Xxx_handler 的方法 - 之後要擴充新的功能，必須按照 Daily_email 介面的定義，實作方法。3. message.php、system_notify.php： - 將「系統通知」與「站內訊息」的 Email 頁面獨立出來。issue #1308 範例 perf:12345678910111213perf: 評核表單列表，優化取得受評者速度原本取得受評者的邏輯會造成載入頁面緩慢（開發機約 52 秒），故做優化。調整方式：原程式碼每個表單迴圈進入 DB 取得受評者資料。改成進 DB 一次撈取全部受評者資料，再回到 PHP 分配資料。結果：開發機載入頁面時間 52 秒 =&gt; 5秒issue #1272 範例 docs:1docs: 新增註解 123docs: 修正型別註解讓 IDE 可以讀取到正確的類別 123docs: 移除過期的註解issue #1229","link":"/blog/git_commit_message_best_practice/"},{"title":"2019 回顧工作與學習歷程","text":"2019 回顧前言2019 年可以說是既充實又偷懶的一年。為什麼呢？因為花了很多時間在學習理論知識，包含：重構、整潔架構、單元測試、領域驅動開發、行為驅動開發 …等等。雖然每個知識看起來像是完全獨立的領域，但對 2019 的我來說，它們都是應付 Legacy Application 的利器。 為什麼又說偷懶？部落格和作品幾乎停擺！學習知識理論不像學習新技術，能把應用新技術的步驟分享到部落格上。因為理論知識必須經過堆疊和內化才能在真實專案中落地實踐。再加上這一年很榮幸受邀到高雄科技大學，帶領一批資工系的學生學習 PHP 式設計課程，備課與上課的時間幾乎吃掉了三個月的休閒時間，也就是平常能用來自學或練習的時間 …。 至於工作呢？這份工作是我搬來高雄的第一份工作，工作內容主要是維護一個大型的 Legacy Application。雖然說是維護，但仍不斷有新需求一直進來。這也是為什麼我必須花費很多時間閱讀如何處理 Legacy Application 的相關書籍和技術。很慶幸我也有機會將學到的知識導入專案中，增加部分功能的彈性；或是阻止部分功能繼續腐敗。改善程式碼品質的成就感讓我更多的動力繼續學習。 可惜 2019 對我來說是一眨眼就結束，到年尾了還來不及紀錄下學習與實踐的東西。所以想先以流水帳的形式紀錄一下 2019 年所學的知識和工作中實踐的技術。 自學主題DDD《領域驅動設計》在 1 月準備系統重構流程的過程中，覺得自己對於「領域模型」不夠瞭解，因此決定拜讀一下《領域驅動設計》，增進自己對領域模型的認知。 DDD 是一個開發論，涵蓋的領域很多，可以說是納入各個程式設計層次的最佳實踐，包含：設計模式、DDD 四層架構（戰術設計）到多個系統間如何劃分邊界（戰略設計）。也因為 DDD 以多種層次來探討程式應該如何「設計」，讓我的思維直接上升好幾個層次，看待程式碼的視角變得更廣、更高階。 DDD 可以說是繼 SOLID 原則後影響我很深的知識，以前我的思維只停留在物件與物件之間， DDD 讓我見識到系統架構如何應用「良好的程式設計」來應對變化，打開了我對系統架構的興趣。不過 DDD 對當時的我來說仍然有很多看不懂的部分（尤其是戰略設計），目前規劃 2020 年會再回來鑽研一次！ 《Clean Architecture》《Clean Architechure》本來並不在我 2019 的書單裡面，但是在學習 DDD 的過程中發現不斷有人拿 Clean Architechure 的架構來跟 DDDLite 架構做比較，這才引起我對 Clean Architechure 的興趣，想說是 Uncle Bob 的著作就安心訂購。 很幸運的，這又是一本可以讓程式設計思維提升好幾個層次的好書！Clean Architechure 可以說是物件導向設計 SOLID 原則的延伸，如果說 SOLID 是指導開發人員如何設計物件，那麼 Clean Architechure 就是指導開發人員如何將多個物件組織起來，並且讓利用一套清晰易懂的規則讓物件與物件彼此協作，完成系統需求所需的功能。 整潔架構中，依照程式的重要程度來劃分層級： 越核心的邏輯越往內圈靠，容易變化的附加邏輯則越往外層靠。 整潔架構中，越內圈的邏輯層次就越高，最內圈屬於業務規則的核心策略，外圈則是圍繞著核心業務規則並隨著需求不斷變化的 機制。這樣劃分的原因是，系統必須保持核心業務邏輯的彈性，以便因應多種不同的需求。所以越內圈的程式碼彈為了保持彈性，也會引入較多的抽象；外圈的程式碼則是按需求所需，透過內圈公開的抽象來存取或擴充核心業務規則，以完成需求所需的功能。 除了分層以外，還需要遵循「相依性規則」： 原始碼依賴關係只能指向內部，朝向更高層級的策略。 這裏指的是，內圈不能知道外圈的存在，包含外圈的變數、類別、函式。只要在內圈看到 import 或是 using 引入外圈的東西就代表違反了規定。這樣的好處是可以將 策略 與 機制 隔離開來。身為一個開發人員必須意識到，將 策略 和 機制 寫在一起是很致命的錯誤！因為 機制（如 UI 介面）的需求變動頻率很大，而且有很大的機率修改到 策略（核心業務邏輯）的程式碼。為了避免 策略 被影響，應該隔離 策略 與 機制，這麼一來被隔離開的程式碼會以不同的速率和原因被修改，並且不會影響到彼此的程式碼。 另外，Clean Architechure 架構的同心圓並不一定要是 4 圈，4 圈只是作者為了方便講解層次而已。 最重要的是要做到「隔離策略與機制」和「遵循相依性規則」! 開發人員必須防止程式碼腐敗手頭上的 Legacy Application 到處都可以看見“參數很多且內容包含大量 if 或 switch 的大函式”，例如： 123456789101112131415161718192021222324252627282930class StudentModel extends Model{ private $db; /** 取得學生列表 */ public function studentList($classId, $homeworkId = null, $bicyclePassYear = null, /** ... 省略 */) { $this-&gt;db-&gt;select('*'); $this-&gt;db-&gt;join('homeworks', 'students.id = homeworks.studentId'); $this-&gt;db-&gt;leftJoin('bicyclePass', 'students.id = bicyclePass.studentId'); $this-&gt;db-&gt;from('students'); // 回家作業繳交狀況列表 if ($homeworkId != null) { $this-&gt;where('homework.id', $homeworkId); $this-&gt;where('homeworks.status', 'done'); } // 腳踏車證繳費記錄列表 if ($bicyclePassYear != null) { $this-&gt;db-&gt;where('bicyclePass.year', $bicyclePassYear); $this-&gt;db-&gt;where('bicyclePass.payStatus', false); } /** ...省略 */ $this-&gt;db-&gt;where('students.classId', $classId); return $this-&gt;db-&gt;get()-&gt;resultArray(); }} StudentModel-&gt;studentList() 是一個正在腐敗的程式碼，因為它的 策略 與 機制 被寫在一起了。這種安排程式的方式往往會在遇到新需求時，就替函式新增幾個參數或 if 來完成新需求的功能。雖然這個案例看起來很小又不複雜，但是，如果開發人員不懂得將策略與機制隔離，不用一下子專案中就會充滿又臭又長的大函式！而且這些大函式常常又是 策略 與 機制 完全攪在一起，開發人員根本難以辨認函式最原始的邏輯是什麼！ 隔離策略與機制，防止程式碼腐敗在我維護的專案中，有一個核心功能為「簽核公文」。使用者需要有一個「簽核歷史紀錄」的畫面來追蹤公文狀態： 「簽核歷史紀錄」功能的資料是經由 Workflow 類別的 process() 函式撈取的： 1234567891011121314151617class Workflow{ /** @var array 所有簽核 */ protected $process = array(); /** @var Workflow_repository 資料庫操作層 */ private $repo; /** * 取得 所有簽核資料 * * @return array */ public function process() { return $this-&gt;repo-&gt;get_process($this-&gt;workflow_id) } // ... 省略 但是目前 Workflow-&gt;process() 只有撈取「簽核資料」是不夠的，因為客戶要求「簽核歷史紀錄」畫面需要更多的資訊： 隱藏匿名簽核成員的名稱 異常的流程須標記成紅色 顯示異常流程的原因 到目前為止可以看到，「簽核歷史紀錄」是屬於與 UI 相關的新需求。在 Clean Architecture 架構的同心圓中，UI 被分類在外圈，也就是 機制。Workflow 類別則是系統的核心功能，故屬於同心圓的內圈，也就是 策略。 如果開發人員直接擴充 Workflow-&gt;process() 的程式碼來完成「簽核歷史紀錄」的功能，等同於“把機制的程式碼寫進策略中”，不但使程式碼變得不易維護，還讓系統中其他調用 Workflow-&gt;process() 的功能都被迫執行「簽核歷史紀錄」的程式碼！ 因此應該遵循 Clean Architecture 的「隔離策略與機制」原則，我們必須隔離Workflow-&gt;process() 與「簽核歷史紀錄」的程式碼。 工作實踐經驗替專案導入 Commit Message 規範打開新公司的程式碼，發現這裡的開發人員沒有統一撰寫 Git Commit Message 的格式，這對一個長期維護的系統來說並不是一件好事！打開 Git History 幾乎找不出;對程式碼異動的意圖與原因，往往只有原作者知道自己的程式碼在做什麼…。 為了解決這個問題，我向眾開發人員提議可以導入 Commit Message 規範，規範的詳細內容已經被記錄在「Git Commit Message 這樣寫會更好，替專案引入規範與範例 」 文章中。 實際案例1. 同事一年前的 Commit Message： 2. 導入規範後，開始會紀錄異動原因與內容： 雖然過了好幾個月才讓大部分的開發人員確實按規範撰寫 Commit Message，但是開發團隊中已經養成一個優良的文化！當良好 Commit Message 持續被 Commit 進程式庫，新進人員將自然而然地遵循前人的格式撰寫 Commit Message。 替專案導入單元測試時間拉回到剛搬到高雄的 2018 末。當時我才剛學會重構和單元測試。面試時，公司的技術顧問說公司想要導入單元測試和重構，希望我一定要進公司幫忙。我也答應了！真的很感謝有這個機會可以實踐導入重構與單元測試（讓我成長很多）。 這間公司的專案使用 CodeIgniter 3 框架（後面簡稱 CI3)，CI3 本身並不是倡導物件導向開發風格的框架，專案的程式碼自然而然也是偏向義大利麵風格。加上專案是維護多年的大系統，在這樣的環境下導入單元測試變得很困難！ 雖然說導入單元測試很困難，但說真的，除非專案使用物件導向風格開發以及有持續重構的習慣，不然不可能輕易導入單元測試吧！而且從身邊碼農朋友的經驗看來，幾乎 100% 的專案沒辦法輕易導入單元測試。所以我把這次的困難當作挑戰，練習如何讓單元測試在一個 Legacy Application 落地。 建立測試框架由於 CI3 架構內建的單元測試功能很少，所以我選用整合了 PHPUnit 的 ci-phpunit-test 來當作專案的測試框架。建立測試框架其實是導入單元測試最快最簡單的步驟，因為其他開發人員並不懂單元測試的相關知識，所以一定要盡可能地簡化撰寫單元測試的複雜度，才能讓單元測試“較有機會”導入開發團隊… 隔離測試環境對 DB 的副作用為了避免測試環境的行為污染 DB 的資料，因此要隔離單元測試與 DB。當時第一個想法是：”在測試環境下一律使用 SQLite”，因為 SQLite 可開啟 In Memory 模式，在記憶體中操作資料庫。當程式關閉後，記憶體內的 SQLite 資料庫也會清空，相當適合測試環境使用（無副作用）。 做法很簡單，只要把 MySQL 的備份檔案轉成 SQLite，再到 CI3 的設定檔案中將測試環境的 DB 驅動器改成 SQLite 就可以了…。 但是實際運作起來，總有一些功能會發生錯誤。原本以為是 MySQL 的資料在轉換成 SQLite 的過程中有失真。經過百般測試後發現，原來是專案很多功能是用手寫的字串來組織 SQL 指令，而不是透過 CI3 的 QueryBuilder 來建立 SQL 指令。手寫的 MySQL 指令讓測試環境中的 SQLite 驅動器編譯失敗。我也因此學到一個教訓： 專案應該盡可能用 QueryBuilder 或 ORM 等資料庫操作層來編寫 SQL，否則專案要切換資料庫種類的時候，會有很高的機率遇到編譯失敗的窘境。 若您的專案也經常使用手寫字串組織 SQL 指令，請不要花時間研究如何使用 SQLite 當作測試環境的資料庫了！ 利用 DB 交易機制避免副作用SQLite In Memory 的方式失敗了，只好找用第二方案：資料庫交易處理機制（Transaction），在測試案例中加入交易機制，測試一結束就執行滾回（Rollback）。為了引入交易機制，建立一個客製化的類別，並繼承 TestCase 類別來銜接 CI3 內建的 DB 交易邏輯，如此一來測試環境的行為就不會對資料庫造成影響了： 123456789101112131415161718192021/** * 功能三：將目前帳號加入至設備可切換帳號 * 1. 將帳號加至 DB 中，where token = Cookie.token */public function test_add_switchable_account(){ $this-&gt;trans_begin(); // @given admin 帳號 $this-&gt;init_switcher(self::COOKIE_STATE); $account = 'admin'; // @when 將 admin 帳號加入至設備可切換帳號 $this-&gt;switcher-&gt;add_switchable_account($account); // @then 帳號 admin 已存至設備可切換帳號 DB 中 $switchable_account = $this-&gt;get_switchable_account_from_db($this-&gt;state-&gt;token); $this-&gt;assertEquals(json_encode([$account]), $switchable_account['switchable_account']); $this-&gt;trans_rollback();} 當然，這個方案不夠好，要是資料庫裡面沒有我需要的測試資料呢？更何況單元測試本來就不應該依賴外部環境（如資料庫）不是嗎？因此後來我嘗試了好幾種建立測試資料的方案，例如 Seeds 或 Faker 等等…。但是公司專案的資料其實非常難建立，若為了測試環境而花費大把時間維護 Seeds 或 Faker 似乎也不是一個好辦法。最後終於在《Specification By Example》這本書找到最佳解決方案！ 拷貝「具有象徵性的真實資料」當作測試資料《Specification By Example》中提及，若專案的較難建立就可以拷貝「具有象徵性的真實資料」，並且把被拷貝的資料存放在某個檔案中，進行測試的時候再將這些檔案轉譯成測試資料。這個方法讓我不再煩惱如何建立測試資料，現在只需要透過 PHP 的 var_export() 或 json_encode() 就可以將需要多道程序才能建立的資料拷貝起來，然後將拷貝的資料放在專門提供單元測試資料的類別(Test Data Provider)，供測試案例使用： 12345678910111213141516171819/** * feat: 表單填寫頁面，選擇題允許輸入文字時，必填時也要檢查輸入文字 input */public function test_check_form_with_options_that_text_writable(){ $this-&gt;describe('必填「多選題」允許輸入文字，當沒有填寫 **所有已挑選選項** 的文字時，不可通過必填檢查', function () { // @given 必填「多選題」允許輸入文字 // @given 沒有填寫所有已挑選的選項之文字方塊 $data_provider = new Test_data_provider(); list($question_block, $input, $ai_id, $role_id) = $data_provider-&gt;form_with_checkbox_that_text_writable_and_not_filled_all_text(); // @when 進行表單必填檢查 $answer_checker = new Answer_checker(); $required_notice = $answer_checker-&gt;check_form($ai_id, $question_block, $input, $role_id); // @then 不通過表單必填檢查 $this-&gt;assertEquals(1, count($required_notice)); });} 替 Bug 撰寫測試案例值得一提的是，拷貝資料的做法除了提供 TDD 或 BDD 測試資料以外，也可以應用在 Debug。每當遇到 Bug 時，就可以把具有「Bug 特徵的輸入值」Copy 起來，並且為這個測試資料建立一個 Bug fix 測試案例。 接著我們要修正程式碼讓 Bug fix 的測試案例通過。當測試案例通過的時候，表示我們把 Bug 修正了。之後遇到新的問題的時候，不但要通過新的 Bug fix 測試案例，也需要通過所有「舊的 Bug fix 測試案例」，才能確保新的 Bug fix 不會破壞原本正常運作的邏輯！ 提出系統重構流程“導入系統重構”是技術顧問在面試中拜託我要幫忙的事項。 由於公司早期的開發人員沒有重構的習慣，所以平常有非常大量的技術債可以讓我進行重構，小至意義不明的變數名稱，大至超多層巢狀 if、foreach，有時候看到巨獸等級的義大利麵還會被嚇到心頭揪一下呢！ 雖然平常我都會隨手進行重構一下 issue 會觸及的程式碼，但是一個團隊中只有一個人進行重構，對多年累積下來的 技術債 來說是不痛不癢的。所以我開始在公司內部的 Wiki 分享重構的知識；觀察專案中的核心功能有哪些；制定重構的 SOP 流程。最後將這些資訊整理一份簡易的簡報，用來跟主管和技術顧問討論要怎麼讓重構落地： 系統重構流程.pdf 簡報大綱簡報中指出系統現有的問題： 專案使用的 MVC 框架在面對數量龐大的模組和多變的需求下，容易變得耦合與臃腫。 專案中充滿著重複的程式碼邏輯，開發人員難以學習系統。 簡報中提出的解決方案： 導入領域模型層，讓程式碼抽象化，降低開發人員學習系統的難度，以及更容易應變變化。 導入 Wiki 文件系統，讓開發人員共同維護文件。 簡報中也提供實際操作範例： 如何撰寫整合測試案例，供重構時回歸測試用。 如何利用重構建立領域模型。 如何撰寫領域模型的單元測試。 這份簡報的原意只是想用來討論 SOP，不過技術顧問看完後就開始調動人員準備執行了！ 持續重構：使用設計模式”擁抱變化”FactoryPoliceFlyweightStatePipelineMiddlewareObersever 導入 Event Sourcing 概念紀錄系統日誌其他經驗高雄科技大學講授 PHP 程式設計課程技術顧問對 1 月份提出的 系統重構流程 相當有興趣，故將重構計畫整合至校外課堂中，帶領一批學生一起參與重構計畫，希望透過讓學生閱讀企業級的程式碼，栽培學生寫出「成熟」的程式。在這個計畫中，公司由經理和我每個禮拜中抽出兩天的時間到高雄科技大學替學生上課，上課的主題是網站系統開發，包含： Gitlab 基本操作 Commit Commit Message 規範 Push Pull Merge Request 概念與用意 HTML5 CSS JavaScript PHP CodeIgniter 3 如何閱讀程式碼 翻轉教室每週兩天的上課時間，對網站開發沒概念的學生來說實在是太少了，因此必須設計一套適合的課程來解決時間太少的問題。最後遵循一套名為「翻轉教室」的教學方式，設計出讓學生在非上課時間也能夠自主學習的課程。 翻轉教育的課程必須事先幫學生定製一系列的主題與範圍（如 HTML、JavaScript)，再給予每個主題的學習資源，讓學生以概括的方式快速了解主題。最後每個主搭配一些題目或情境，讓學生以解決問題導向的方式進行學習。另外，為了因應學生素質不一致的問題，教學資源和題目包含淺至深的議題，讓進度較快的學生不必等其他同學的進度，就能持續往下練習。 開始上課前幾週，只需要幫學生起個頭，簡介一下主題的內容與主題之間的關聯，並且指派每週作業。下課後學生就會自行找出實踐作業的相關知識，從中學習知識並且得到解決問題的成就感。 當學生熟悉翻轉教室的形式後，每次到學校上課都是與學生探討在作業中遇到常見錯誤、困難，並且提出良好的解決方案或學習方向。 Gitlab 當作回饋機制翻轉教室主要是讓學生透過自主學習的方式進行學習，因此必須有個回饋機制讓學生知道自己學得正不正確。原本翻轉教室是利用每次上課時間，讓學生分享作業；以及講師帶領學生探討寫作業過程中遇到的問題來當作回饋。 我和經理選擇導入更適合開發人員的 Gitlab 來實踐回饋機制： 利用 Milestone 要求學生將作業繳交至 Gitlab。 issue 功能則像 StackOverflow，讓學生可以公開討論自己的問題，個性羞怯的學生也能在 Gitlab 與講師或同學進行交流。 Merge Request 機制用來審視學生的作業，將學生做得不好的地方與建議即時回饋給學生。 利用 Merge Request 導入良好的開發觀念Merge Request 讓我變成學生的個人教練，學生上傳程式碼後會立刻得到錯誤報告與改善建議。發現常見問題時，也可以 tag 所有學生一起討論並學習解決方案。 我和經理在 Merge Request 階段進行嚴謹的 Code Review，審查內容包含 Commit Message 規範、統一 Coding Style、重構和 Clean Code 觀念 …等，只要不合格就退回並給予改善建議。前幾個作業中，學生都被多次退回才通過 Code Review。 不到一個月，學生的程式碼變得相當成熟，不再有意義不明的變數名稱，也不會寫出巢狀 if，並且有能力釐清程式碼的職責。甚至能力較好的學生還會回頭重構前幾次的作業呢！ Code Review 除了訓練學生效果很好以外，我認為一個 IT 公司也應該好好利用 Code Review 持續培養開發人員良好的開發習慣與思維！","link":"/blog/2019_review/"},{"title":"物件導向設計原則：開放封閉原則，定義、解析與實踐","text":"開放封閉原則（Open-Closed Principle） 定義： Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.--軟體中的類別、模組、函式等等應該開放擴充，但是封閉修改。 白話版本為： 當系統需要擴充功能時，應該藉由 增加新的程式碼 來擴充系統的功能，而 不是藉由修改原本已經存在的程式碼 來擴充系統的功能。 開放封閉原則為軟體開發的 首要原則，很多軟體開發原則都是建構在這短短一句話之上，因此可以通過此原則引伸出其他原則。很多時候一個程式具有良好的設計，往往說明它是符合開放封閉原則。 目的 隔離業務邏輯與附加邏輯，使業務邏輯更易於擴充，以便因應需求變化。 解析什麼是業務邏輯？附加邏輯？一個系統總有幾個極具價值的核心邏輯，這些核心邏輯實現了企業或專案的業務規則（Business Rule）與 Know How。通常可以從核心邏輯延伸出更多功能，提供使用者的便利性，以下將這些核心業務邏輯簡稱為「業務邏輯」。也就是說系統中有可能 20% 是業務邏輯，剩下的 80% 是圍繞著業務邏輯延伸出來的附加邏輯。 舉例來說，一個診所掛號系統一開始只有「掛號與叫號」功能。但若需要的話，也可以延伸出「叫號時發送簡訊提醒患者」功能。掛號系統的案例中業務邏輯是「掛號與叫號」；而「叫號時發送簡訊提醒患者」則是 隨著時間與新需求延伸出來的附加邏輯。 為什麼要隔離 業務邏輯 與 附加邏輯？和軟體複雜的特質 軟體熵(Software entropy) 有關，指系統在經過修改後，程式碼的無序程度(意圖流失程度)與複雜程度皆會上昇。 需求變更和除錯是系統修改的主因，系統會隨著時間不斷衍生出新需求。這些需求可能是工程浩大的新功能；也可能是為了某個特定案例只使用一次的需求。甚至客戶往往在看見實際功能後，才想到有更好的解決方案或缺少哪些細項。於是剛釋出的功能馬上又進入重工（Rework）階段。 若開發人員不懂得將業務邏輯與附加邏輯分開，往往為了完成新需求，把附加邏輯寫在業務邏輯裡面，替業務邏輯擴充行為。這種做法一但遇到需求不停出現時，業務邏輯 與 附加邏輯 會漸漸地糊在一起變成一個大泥團導致程式脆弱化。新增需求和除錯更容易引入新的 Bug，解決新的 Bug 又引入更新的 Bug…。 （圖一）中的程式碼在專案中隨處可見，當 附加邏輯 與 業務邏輯 耦合在一起時，業務邏輯 會變得很難除錯、重複使用以及擴充，這些因素都會拉長開發時程，增加維護系統的成本。 因此開發人員應該要有個認知： 雖然需求並不是程式設計環節能控制的，但是程式碼應該要能夠適應快速多變的需求。 業務邏輯本身只需要關心業務規則（Business Rule），不應該和附加邏輯耦合在一起。一定要隔離業務邏輯與附加邏輯，才能確保業務邏輯的彈性。一旦業務邏輯有了彈性，程式就較容易面對需求變化。 開放擴充點，由外部注入附加邏輯新需求不斷出現，修改業務邏輯來擴充附加功能卻會促進 軟體熵 成長，增加維護系統的困難度。為了避免 軟體熵 的問題，開放封閉原則指導開發人員在面對需求變化時應該要： 盡可能減少對既有程式碼的修改，並開放擴充點，讓新需求可以從外部擴充業務邏輯。 實際上 開放封閉原則的設計思維 早在物件導向技術出現之前就存在，並且被廣泛應用在各種層面，從程式設計乃至框架、系統層級： 程式設計層面：jQuery ajax透過 $.ajax 的 done, fail, always 等公開函式從外部注入閉包，擴充 $.ajax 行為： 1234567891011121314$.ajax({ method: \"POST\", url: \"some.php\", data: { name: \"John\", location: \"Boston\" }}) .done(function() { alert(\"success\"); }) .fail(function() { alert(\"error\"); }) .always(function() { alert(\"complete\"); }); 框架層面：Laravel Controller透過繼承 MVC 框架內建的 Controller 類別，擴充 Controller 層的行為： 123456789101112&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class HelloController extends Controller{ public function index(Request $request){ return 'Hello World!'; }} 框架層面：React.js透過繼承 React.Component 類別，擴充 Component 的行為： 12345class Welcome extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; }} 其他範例： JavaScript 透過註冊 event 事件，擴充瀏覽器行為。 瀏覽器透過安裝擴充套件，擴充瀏覽器行為。 手機透過安裝 APP，擴充手機 OS 行為。 … 上述這些耳熟能詳的範例中，每個技術都被應用到成千上萬個不同的需求。這些高彈性技術的共通點是：至少有一個開放的擴充點，讓開發人員可以寫入自己的邏輯來完成功能。 開放封閉原則 讓開發人員不需要修改已經造好的輪子，就可以完成自己所需的功能。 這也是為什麼軟體技術能夠以海量增長的原因。但是開放封閉原則的原理是什麼呢？ 原理：利用抽象隔離不相關的程式 解除耦合的方法，就是讓程式碼不知道彼此的存在。 程式碼可以透過繼承、引入介面或注入閉包等技術，讓附加邏輯可以”共用公開的介面“。業務邏輯在需要擴充的時機，則須透過 統一的公開介面 來調用附加邏輯。 這其實是利用 多型的特性，在業務邏輯和附加邏輯之間引入一個抽象（繼承、介面、閉包等）： 對業務邏輯來說，原本寫死在業務邏輯裡面的附加邏輯將被 抽象的變數 取代。只有等程式碼運行中，藉由 當時實作抽象介面的實體（類別、閉包） 來決定附加邏輯的行為。 對附加邏輯來說，只需要按照 抽象介面 的定義，實作完成新需求所需的程式。最後注入業務邏輯中，以便擴充業務邏輯。 找出業務邏輯與附加邏輯的邊界 開發人員必須懂得如何找出業務邏輯與附加邏輯的邊界，才能從中開放擴充點引入抽象隔離彼此。 簡單有效的方法是，把重要與不重要的事情分開。例如 UI 介面所需的邏輯與業務規則無關，所以它們之間應該要有一個邊界。也可以 已變化為軸的地方 繪製邊界，邊界另一側的元件將以不同的速率以及不同的原因改變： 附加邏輯 與 業務邏輯 相比，彼此在不同的時間以不同的速率改變，因此它們之間應該有個邊界； 附加邏輯 與 其他附加邏輯 相比，每個附加邏輯都在不同的時間和不同的原因改變，所以它們之間應該也要有邊界。 說到底，其實一直都是 單一職責原則 指導我們應該如何切割邊界。 引入抽象後，業務邏輯與附加邏輯 只能透過抽象介面與彼此互動。如此一來，業務邏輯可以專注於本身的業務規則（Business Rule），而附加邏輯則可以隨時被多個不同的實作替換掉，並且業務邏輯完全不需要關心這些事。 一但建立起開放封閉原則的架構（圖四），就能擁有一個安全的防火牆。程式碼之間的變動不會傳播出去。附加邏輯的變動不會影響到業務邏輯。 事實上，軟體開發技術的歷史就是「如何方便地建立 Plugin 來奠定可擴展和可維護的系統架構」的故事 - Uncle Bob. 《Clean Architecture》 實踐：每日信件功能從原理中可以發現，開放封閉原則能夠解除業務邏輯與附加邏輯之間的耦合，並且保持業務邏輯的彈性。接下來將透過一個「每日信件功能」的案例，講解如何讓開放封閉原則落地。 某校園系統中，有一個寄信排程會在每天凌晨寄送「每日信件」，最初的需求為： 1. 最初需求：寄送使用者昨天收到的系統通知。1234567891011121314151617181920212223242526class Send_today_mail extends MX_Controller{ public function index() { /** 1. 撈取信件的內容，並產生信件 HTML */ // 取得所有使用者昨天收到的系統通知 $system_notifies = $this-&gt;notify_api-&gt;get_yesterday_notify(); // 依照收件者的 email 分群通知訊息 $system_notifies = $this-&gt;group_system_notify_by_email($system_notifies); // 產生信件 HTML 內容 $mail_contents = $this-&gt;make_mail_contents($system_notifies); /** 2. 寄送信件 */ $this-&gt;send_mail($mail_contents); } /** 建立系統通知信件 */ private function get_yesterday_notify() {/** ... */} private function group_system_notify_by_email($system_notifies) {/** ... */} private function make_notifies_template_variables($notifies, $tplVar = array()) {/** ... */} private function make_mail_contents($system_notifies){/** ... */} private function send_mail($mail_contents) {/** ... */}} 第一版本的程式碼中可以看見寄信功能主要分兩個部分： 撈取信件的內容，並產生信件 HTML 寄送信件 Send_today_mail 的最初版本中，總共只有 93 行程式碼。 2. 第二需求：寄送使用者昨日收到的 Messenger 訊息123456789101112131415161718192021222324252627282930313233343536class Send_today_mail extends MX_Controller{ public function index() { /** 1. 撈取信件的內容，並產生信件 HTML */ // 取得所有使用者昨天收到的系統通知 $system_notifies = $this-&gt;notify_api-&gt;get_yesterday_notify(); // 依照收件者的 email 分群通知訊息 $system_notifies = $this-&gt;group_system_notify_by_email($system_notifies); // 取得 Messenger 使用者、對話群組 id list($message_users, $group_ids) = $this-&gt;message_api-&gt;get_all_message_users(); // 取得昨日的 Messages $messages = $this-&gt;get_yesterday_message($group_ids); // 產生信件 HTML 內容 $mail_contents = $this-&gt;make_mail_contents($system_notifies, $messages, $message_users); /** 2. 寄送信件 */ $this-&gt;send_mail($mail_contents); } /** 建立系統通知信件 */ private function get_yesterday_notify() {/** ... */} private function group_system_notify_by_email($system_notifies) {/** ... */} private function make_notifies_template_variables($notifies, $tplVar = array()) {/** ... */} /** 建立 Messenger 訊息信件 */ private function get_yesterday_message() {/** ... */} private function message_filter($messages, $group_id) {/** ... */} private function make_message_template_variables($messages, $message_users, $tplVar) {/** ... */} /** 合併信件內容並寄送信件 */ private function make_mail_contents($system_notifies, $messages, $message_users){/** ... */} private function send_mail($mail_contents) {/** ... */}} 第二版本加入了新需求，Send_today_mail 的程式碼一下子從 93 行增加到 295 行。為了產生 系統通知 和 Messages 的信件 HTML 內容，make_mail_contents() 函式已經開始出現耦合。 3. 第三需求：寄送明日課程內容給教師1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Send_today_mail extends MX_Controller{ public function index() { /** 1. 撈取信件的內容，並產生信件 HTML */ // 取得所有使用者昨天收到的系統通知 $system_notifies = $this-&gt;notify_api-&gt;get_yesterday_notify(); // 依照收件者的 email 分群通知訊息 $system_notifies = $this-&gt;group_system_notify_by_email($system_notifies); // 取得 Messenger 使用者、對話群組 id list($message_users, $group_ids) = $this-&gt;message_api-&gt;get_all_message_users(); // 取得昨日的 Messages $messages = $this-&gt;message_api-&gt;get_yesterday_message($group_ids); // 取得明日的課程資訊 $tomorrow_course = $this-&gt;get_tomorrow_course(); // 取得課程教師資訊 $course_ids = array_column($tomorrow_course, 'course_id'); $teachers = $this-&gt;course_api-&gt;get_course_teachers($course_ids); // 產生信件 HTML 內容 $mail_contents = $this-&gt;make_mail_contents($system_notifies, $messages, $message_users, $tomorrow_course, $teachers); /** 2. 寄送信件 */ $this-&gt;send_mail($mail_contents); } /** 建立系統通知信件 */ private function get_yesterday_notify() {/** ... */} private function group_system_notify_by_email($system_notifies) {/** ... */} private function make_notifies_template_variables($notifies, $tplVar = array()) {/** ... */} /** 建立 Messenger 訊息信件 */ private function get_yesterday_message() {/** ... */} private function message_filter($messages, $group_id) {/** ... */} private function make_message_template_variables($messages, $message_users, $tplVar) {/** ... */} /** 建立 明日課程 信件 */ private function get_tomorrow_course() {/** ... */} private function get_course_teachers(course_ids) {/** ... */} private function make_course_start_template_variables() {/** ... */} /** 合併信件內容並寄送信件 */ private function make_mail_contents($system_notifies, $messages, $message_users, $tomorrow_course, $teachers){/** ... */} private function send_mail($mail_contents) {/** ... */}} 第三個版本，Send_today_mail 的總行數來到 504 行，make_mail_contents() 函式的耦合更加嚴重。 到目前為止，Send_today_mail 已經變得不太容易維護，這個 Controller 裡面包含了 12 個函式，其中好幾個函式卻都是在做一樣的事情：「撈取信件的內容，並產生信件 HTML」。 為了避免 Send_today_mail 因新需求的出現不斷膨脹，接下來將開始替 Send_today_mail 進行一次重構。這次重構的目的將是引入抽象，拆散 隨著時間增加的附加邏輯。 第一次重構：拆散職責1234567891011121314151617181920class Send_today_mail extends MX_Controller{ /** * 寄送系統每日收到的所有通知訊息 */ public function index() { /** 1. 撈取信件的內容，並產生信件 HTML */ $email_maker = new Today_email_maker(); $email_maker-&gt;add_handler(new System_notify_handler()); $email_maker-&gt;add_handler(new Message_handler()); $email_maker-&gt;add_handler(new Course_start_handler()); $mail_contents = $email_maker-&gt;make_mail_contents(); /** 2. 寄送信件 */ $this-&gt;send_mail($email_contents); } private function send_mail($mail_contents) {/** ... */}} 上面是重構後的結果，Send_today_mail 的程式碼大幅減少，可讀性也有提高。 這樣拆分職責的邏輯是「已變化為軸的地方劃分界限」：Send_today_mail 從第一次發佈以來就一直新增 信件種類，這些 信件種類 最後都需要透過 make_mail_contents() 產生信件內容。那麼隨著新需求冒出來的信件種類，就是容易變動的地方，也就是 附加邏輯；負責產生信件 HTML 內容的 make_mail_contents() 則是在流程中不變的邏輯，故可視為 業務邏輯。 找出 業務邏輯 與 附加邏輯 後，即可將邏輯拆分成下面結構： 將產生多個信件 HTML 內容的 make_mail_contents() 搬移至 Today_email_maker 類別。 負責 撈取各種信件種類內容 的邏輯則拆散至各自的類別： System_notify_handler Message_handler Course_start_handler 具體細節如下： 在（圖五）結構圖中可以看見業務邏輯和附加邏輯之間引入一個抽象介面（Daily_email）。業務邏輯 透過公開 add_handler(Daily_email $handler) 函式，讓 Controller 層可以從外部注入 附加邏輯。附加邏輯則須按照 Daily_email 介面的定義，實作完成新需求所需的程式碼。 這是利用多型的特性，讓 add_handler(Daily_email $handler) 可以接收任何有實作 Daily_email 介面的物件。這也是為什麼 Controller 層可以對 Today_email_maker 注入多個附加邏輯類別的原因。 下面附上重構後的範例程式碼： 1234567891011121314151617181920212223242526272829303132interface Daily_email{ /** 取得今日信件內容 */ public function get_email_content(); /** 建立 Email HTML 樣板變數 */ public function make_email_template_variables(); /** 建立 Email HTML 內容 */ public function make_email_content();}class Today_email_maker{ /** @var Daily_email[] */ private $handlers = array(); public function add_handler(Daily_email $handler) { array_push($this-&gt;handlers, $handler); } public function make_mail_contents() { $mail_contents = array(); foreach ($this-&gt;handlers as $handler) { $handler-&gt;get_email_content(); $handler-&gt;make_email_template_variables(); array_push($mail_contents, $handler-&gt;make_email_content()); } return $mail_contents; }} 附加邏輯如下： 1234567891011121314151617181920212223242526class System_notify_handler implements Daily_email{ public function get_email_content() { /** ... */} public function make_email_template_variables() { /** ... */} public function make_email_content() { /** ... */} private function xxxx() { /** ... */} /** ... */}class Message_handler implements Daily_email{ public function get_email_content() { /** ... */} public function make_email_template_variables() { /** ... */} public function make_email_content() { /** ... */} private function xxxx() { /** ... */} /** ... */}class Course_start_handler implements Daily_email{ public function get_email_content() { /** ... */} public function make_email_template_variables() { /** ... */} public function make_email_content() { /** ... */} private function xxxx() { /** ... */} /** ... */} 重構前，只要每新增一種信件，make_email_content 就會耦合新的信件種類資料，以便產生信件 HTML 內容。 12345678910111213141516171819/** 重構前 Send_today_mail.php */private function make_mail_contents($system_notifies, $messages, $message_users, $tomorrow_course, $teachers){/** ... */}{ // 建立 Notifies 信件樣板變數 $tplVar = $this-&gt;make_notifies_template_variables($notifies); // 建立 Messages 信件樣板變數 $tplVar = $this-&gt;make_message_template_variables($messages, $message_users, $tplVar); // 建立 明日課程 信件樣板變數 $tplVar = $this-&gt;make_tomorrow_course_template_variables($tomorrow_course, $teachers, $tplVar); // 建立信件樣板 $mail_contents = []; foreach ($tplVar as $target_mail =&gt; $template_data) { // 以使用者的 email 做區隔 $mail_contents[$target_mail] = $this-&gt;load-&gt;view('send_today_notify_mail/mail_template', $template_data, true); } return $mail_contents;} 重構後，不管再新增多少種類的信件，Today_email_maker 都不需修改任何程式碼（封閉修改）。只需新增實作 Daily_email 介面的附加邏輯即可完成新需求（開放擴充）。而且還可以隨時移除任何一種信件種類。這就是利用開放封閉原則的成果，讓程式碼可以適應需求變化。 1234567891011121314151617/** 重構後 Today_email_maker.php */public function add_handler(Daily_email $handler){ array_push($this-&gt;handlers, $handler);}public function make_mail_contents(){ $mail_contents = array(); foreach ($this-&gt;handlers as $handler) { $handler-&gt;get_email_content(); $handler-&gt;make_email_template_variables(); array_push($mail_contents, $handler-&gt;make_email_content()); } return $mail_contents;} 接受第一次愚弄你可能已經發現了，引入抽象後程式碼變得比重構前還要複雜。若每個新功能都要符合開放封閉原則，系統結構會變得極其複雜，而且還會有很多抽象沒有實質效益。 因此 Uncle Bob 建議可以接受不合理的程式碼帶來的第一次愚弄。在最初寫程式的時候，可以先假設變化永遠不會發生，這有利於我們迅速完成需求。當變化發生並且對我們接下來的工作造成影響的時候，再回過頭來封裝這些變化的地方。確保未來不會掉進同一個坑里。 結論在寫程式的時候，可以把開放封閉原則當作目標，因為設計良好的程式通常都經得起開放封閉原則的考驗。也有人說設計模式就是幫良好的設計取個名字，因為設計模式幾乎都是遵守開放封閉原則的。開放封閉原則延伸出單一職責原則、依賴倒置原則等其他設計原則，其實都只是為了完成開放封閉原則這個目標的過程。 開放封閉原則是終極目標，很少人可以無法百分之百做到，但只要朝著原則的方向努力，就可以不斷改善系統的架構，讓程式碼可以“擁抱變化“。 系列文章： 淺談物件導向 SOLID 原則對工程師的好處與如何影響能力 再談 SOLID 原則，Why SOLID? 物件導向設計原則：單一職責原則，定義、解析與實踐 物件導向設計原則：開放封閉原則，定義、解析與實踐 推薦閱讀： Clean Architecture 無瑕的程式碼－整潔的軟體設計與架構篇","link":"/blog/solid_ocp_definition_and_practices/"},{"title":"物件導向設計原則：單一職責原則，定義、解析與實踐","text":"單一職責原則(Single responsibility principle) 定義： A class should have only one reason to change.以一個類別來說，應該只有一個引起它變化的原因。 ”等等，這是在說人話嗎？還是我理解能力不夠好？“ 這是我第一次讀到 SRP 原則定義的反應，當時覺得 SOLID 每個原則都是文字天書。若你也有跟我一樣的反應，不要緊張，大家都經歷過這個過程。我將會在本文中以自己的體悟來講解觀念，實務經驗演示如何實踐 SOLID 原則。 單一職責原則是 SOLID 原則中看起來最容易明白，卻也是最容易讓人混淆的原則。因為很多人並不清楚 職責 是什麼，甚至誤以為一個類別只能做一件事。接下來的文章中會依序講解原則的目的；解決什麼問題；如何實踐。 目的： 提高程式碼的內聚性，讓程式碼更易於管理和重複使用。 解析：什麼是內聚？在英文辭典中 內聚(Cohesion) 的同義詞為一致性、凝聚、結合等等，描述相關的事務如何聯繫在一起。在軟體開發中，高質量程式碼通常是高內聚性的，內聚 程式碼的特徵為： 每個程式碼片段都只關注一件事情 當每段程式碼只關注一件事情時，程式碼會更容易被理解和處理，且相較 低內聚 的程式碼來說更容易編寫。 什麼情況會造成低內聚?當程式碼包含一個以上「互不相關」的邏輯或意圖時，程式碼的內聚性就會降低。(一般而言，低內聚的程式碼代表高耦合1) 程式碼的內聚性一但降低，閱讀與維護程式碼的難度就會提升。當你必須從一個大函式裡面修改其中一小段邏輯，若不先花時間讀懂函式中每段程式碼之間的關係就直接修改程式碼，很容易破壞函式原先可正常運作的程式碼。為了避免對程式碼造成破壞，開發人員開發過程總是變成：花費 80% 時間閱讀程式碼，真正編寫程式碼的時間卻只有 20%。對於維護一個系統來說，這種情況除了相當浪費成本以外，也相當折磨開發人員的心情，更糟的是，每次回來維護又要重新讀一次程式碼。 單一職責原則對專案的重要性？單一職責原則乍看之下好像很簡單，但實踐過程其實困難重重。現實狀況常常是：專案起初幾個版本的程式碼意圖都相當簡單明瞭，但是當需求隨著時間增長再加上開發時程短促，讓開發人員不斷在原本的程式碼上堆疊新的程式碼。最後 舊程式碼與新程式碼糾纏在一起，使得程式碼的意圖和邊界漸漸變得模糊且互相耦合。若在意圖模糊的程式碼上繼續擴充或修改，則會使程式碼的意圖逐漸流失並且擴大影響範圍，最後變成 技術債 折磨維護專案的人員。 因此，單一職責原則指導開發人員在建立新功能時，不應該把意圖不同的程式碼擺放在一起。 讓每段程式碼的意圖保持清晰，確保程式碼的意圖不會隨著需求或時間增長而流逝。 為什麼意圖如此重要呢？維護專案最怕的就是修改程式碼時 不知道當初的開發者為什麼要這樣設計程式。要是冒然修改程式碼，就容易使功能發生錯誤。這種不確定的感覺會變成開發人員心中的恐懼，對無知的恐懼常在開發人員的心中作祟：「如果程式碼能好好運作，就別碰了吧！」這也是為什麼專案中經常會存在一段醜陋的程式碼，卻沒人去整理的原因。意圖模糊的程式碼一但被留下來就會成為專案長久的痛處，只要新需求和這些程式碼相關，開發時程就會變得緩慢且難以估計。 若程式碼的意圖有被保留下來，這些程式碼就有機會被改善。保持程式碼意圖的方法就是盡量隔離意圖不同的程式碼，避免意圖不相同的程式碼耦合在一起，造成程式碼的意圖與界線都變得模糊。 隔離意圖也是解除耦合單一職責原則並不只有保持程式碼意圖這項優點而已，因為隔離意圖的過程中，也會解除不經意耦合的程式碼。開發的過程中常常 為了共用某些變數或邏輯，將意圖不相同的程式碼安排在一起；或單純只是因為處理的資料相同而被擺放在一起。雖然程式碼可以運作，卻也造成不同意圖的程式碼互相耦合。耦合的程式碼對維護專案來說是相當致命的。 意圖不相同的程式碼，通常也意味著修改的時機與頻率不相同。 新舊程式碼因為共用變數或邏輯而被安排在一起，常常會因為需求異動，只需要調整 其中一小段程式碼。但是開發人員卻需要花費很多時間閱讀與 當前需求 不相關的程式碼，只怕程式碼的異動會造成其他程式碼無法正常運行。 以（圖ㄧ）為例，不同意圖的程式碼共用一個 Foreach 迴圈，讓開發人員很難判斷修改任一變數後，會不會造成其他程式碼發生錯誤；如果將每個意圖隔離開來，每段程式碼只需要維護自己的小迴圈，即可減少開發人員閱讀程式碼的時間與發生錯誤的機率。 實踐接下來的章節將進入實作練習「如何導入單一職責原則」的階段。練習過程中，會先建立一個功能，並且隨著新需求不斷加入新的程式碼。最後再藉由單一職責原則，隔離不同意圖的程式碼，使每段程式碼的意圖得以保持清晰、且不互相耦合。 如何隔離意圖？隔離意圖前，須先學會找出可能發生「意圖糾纏」的地方導入單一職責原則的過程中，較困難的部分是如何發現意圖不同的程式碼。可能有多個需求都是在處理同一種資料，開發人員也習慣性地將處理相同資料的程式碼擺放在一起。如此一來，不同意圖的程式碼就容易堆疊在一起。因此，除了把處理相同資料的程式碼擺放在一起外，還必須做到隔離不同意圖的程式碼。 接下來以一個簡單的範例來「意圖糾纏」的程式碼是如何產生的： 範例：學生列表某系統最原始的版本中，有一個「學生列表」的功能，其需求為：顯示某班級的所有學生。 其程式碼分為 StudentController 與 StudentModel 兩部份。Controller 負責接收 HTTP 參數，並返回學生資料。Model 負責從資料庫撈取學生資料。 1234567891011121314151617181920212223242526class StudentController extends Controller{ /** var StudentModel **/ private $model; public function studentList() { $classId = $this-&gt;input-&gt;get('classId'); return $this-&gt;model-&gt;studentList($classId); }}class StudentModel extends Model{ private $db; public function studentList($classId) { $this-&gt;db-&gt;select('*'); $this-&gt;db-&gt;from('students'); $this-&gt;db-&gt;where('students.classId', $classId); return $this-&gt;db-&gt;get()-&gt;resultArray(); }} 新需求：已完成作業的學生列表隨著新需求新增，老師想要有一個「已完成作業的學生列表」的畫面。因此開發人員在 Controller 新增一個 studentListByHomeworkStatus() 函式，並且調整 StudentModel 的 studentList() 函式以便撈取對應的查詢條件： 1234567891011121314151617181920212223242526272829303132333435363738class StudentController extends Controller{ /** var StudentModel **/ private $model; /** 顯示某班級的所有學生 **/ public function studentList($classId) {/** ...省略 */} /** 已完成作業的學生列表 **/ public function studentListByHomeworkStatus() { $classId = $this-&gt;input-&gt;get('classId'); $homeworkId = $this-&gt;input-&gt;get('homeworkId'); return $this-&gt;model-&gt;studentList($classId, $homeworkId); }}class StudentModel extends Model{ private $db; public function studentList($classId, $homeworkId = null) { $this-&gt;db-&gt;select('*'); $this-&gt;db-&gt;join('homeworks', 'students.id = homeworks.studentId'); $this-&gt;db-&gt;from('students'); if ($homeworkId != null) { $this-&gt;where('homework.id', $homeworkId); $this-&gt;where('homeworks.status', 'done'); } $this-&gt;db-&gt;where('students.classId', $classId); return $this-&gt;db-&gt;get()-&gt;resultArray(); }} 臨時需求：尚未繳交 108 學年度腳踏車證費用的學生列表突然有臨時的需求，校務人員需要匯出「尚未繳交 108 學年度腳踏車證費用的學生列表」，於是開發人員又做了以下變動： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class StudentController extends Controller{ /** var StudentModel **/ private $model; /** 顯示某班級的所有學生 **/ public function studentList($classId) {/** ...省略 */} /** 已完成作業的學生列表 **/ public function studentListByHomeworkStatus() {/** ...省略 */} /** 尚未繳交 108 學年度腳踏車證費用的學生列表 **/ public function studentListThatNotPaidBicyclePassFee() { $classId = $this-&gt;input-&gt;get('classId'); $bicyclePassYear = 108; return $this-&gt;model-&gt;studentList($classId, null, $bicyclePassYear); }}class StudentModel extends Model{ private $db; public function studentList($classId, $homeworkId = null, $bicyclePassYear = null) { $this-&gt;db-&gt;select('*'); $this-&gt;db-&gt;join('homeworks', 'students.id = homeworks.studentId'); $this-&gt;db-&gt;leftJoin('bicyclePass', 'students.id = bicyclePass.studentId'); $this-&gt;db-&gt;from('students'); if ($homeworkId != null) { $this-&gt;where('homework.id', $homeworkId); $this-&gt;where('homeworks.status', 'done'); } if ($bicyclePassYear != null) { $this-&gt;db-&gt;where('bicyclePass.year', $bicyclePassYear); $this-&gt;db-&gt;where('bicyclePass.payStatus', false); } $this-&gt;db-&gt;where('students.classId', $classId); return $this-&gt;db-&gt;get()-&gt;resultArray(); }} 新需求只會不斷地出現隨著時間的推移，功能也會不斷出現新需求，需求幾乎是無限上綱的。例如：以性別撈取學生、以戶籍地址撈取學生、撈取沒繳午餐費的學生、撈取午餐吃素的學生、已經繳交學雜費撈取學生 …等。 當這些需求都被寫在同一個功能裡面時，就能發現 studentList() 函式中充滿意圖不同的程式碼： 從（圖二）可看到 studentList() 總共包含了 8 個意圖的程式碼，其中 6.撈取沒繳午餐費的學生 和 7.撈取午餐吃素的學生 還共用同一段 Join 邏輯，產生了不經意的耦合。 這樣的程式碼會有下列問題： 不易閱讀與維護：為了避免改壞其他意圖的程式碼，每次進來改程式碼都要先讀過所有與 當前需求 不相關的程式碼。 額外的工作：不同意圖的程式碼被耦合在一起，造成部分意圖被迫執行不同意圖的程式碼。除了讓功能變得不穩定以外，日積月累還有可能成為系統的效能瓶頸。 studentList() 範例中，部分意圖被迫執行其他意圖的 Join 邏輯。 修改不能局部化：每個意圖共用同一個函式，當某個意圖不小心寫入嚴重錯誤 Bug，會連同其他意圖的功能也跟著發生錯誤。 不同的變動率：每個意圖會以不同的時機與頻率修改程式碼，讓原本正常運作的功能變得不穩定，隨時會被改成壞掉的。 學生列表的範例相當簡單，看起來影響不大，很容易解決。但實際上 意圖交纏 的問題常常出現在系統各處，而且每個問題的耦合程度與複雜度都不相同。通常等你意識到程式碼很難修改時，耦合的問題也已經很嚴重了。 因此，每個開發人員都應該學會如何隔離意圖。 隔離意圖：功能插件化 的思維解決意圖耦合最快的方式就是將 功能插件化，藉由 增加新的程式碼 來擴充系統的功能，而 不是藉由修改原本已經存在的程式碼 來擴充系統的功能，其原理為： 將「核心的邏輯」與「附加功能的邏輯」隔離開來，讓附加功能擴充核心功能的邏輯。 實務上可以從觀察程式碼中發現，會隨著需求增長的程式碼，通常是附加功能的邏輯；不會隨著需求被改變的程式碼，通常是核心邏輯。 這種開發思維對不熟悉物件導向的人來說應該覺得很奇怪，但是將 功能插件化 早在軟體開發領域隨處可見，應用層面從程式開發、框架、系統層級都有： JavaScript 透過註冊 event 事件，擴充瀏覽器行為。 MVC 框架透過繼承 Controller 或 Model 擴充框架的行為，以便完成功能。 瀏覽器透過安裝擴充套件，擴充瀏覽器行為。 手機透過安裝 APP，擴充手機行為。 以「學生列表」功能為例，核心的邏輯為：撈取學生列表；附加功能的邏輯為：其他完成新需求的程式碼。 接下來將 導入介面(Interface) 讓「學生列表」功能插件化，隔離意圖不同的程式碼。 Note: 因本篇文章探討的是物件導向設計原則，故以介面（Interface）來實踐功能插件化，但並不表示功能插件化只可以透過介面或物件導向的方式實踐。 導入介面（Interface）實踐 功能插件化一共有 4 步驟： 找出核心邏輯 開放擴充點，供核心邏輯隨時可以使用插件。 當有需求時，按照擴充點的定義，實作新的插件以便完成需求。 將新的插件注入核心邏輯中。 1. 找出核心邏輯，並開放擴充介面各種「學生列表」功能中，最常被執行的功能為 StudentModel-&gt;studentList()，因此我們可以斷定核心邏輯應該在這個函式裡面，並做了些調整： 123456789101112131415161718192021222324252627282930// ConditionPlugin：擴充 DB 查詢條件的介面interface ConditionPlugin { public function setWhereCondition($db);}class StudentModel extends Model{ private $db; /** @var ConditionPlugin */ private $plugin = null; /** 開放從外面注入擴充邏輯 */ public function setConditionPlugin(ConditionPlugin $plugin) { $this-&gt;plugin = $plugin; } public function studentList($classId) { $this-&gt;db-&gt;select('*'); $this-&gt;db-&gt;from('students'); $this-&gt;db-&gt;where('students.classId', $classId); // 執行擴充邏輯 if ($this-&gt;plugin) { $this-&gt;plugin-&gt;setWhereCondition($this-&gt;db); } return $this-&gt;db-&gt;get()-&gt;resultArray(); }} 這個步驟中，首先要找出核心邏輯。您可以發現 studentList() 只被保留了最核心的邏輯，也就是隨著需求與時間不變的邏輯。其他的邏輯暫時被忽略了，它們都是附加功能的邏輯，等等會再提及。 找出最核心的邏輯後，下個步驟是開放擴充點。範例中我做了四件事，讓 studentList() 開放了擴充點： 新增一個 ConditionPlugin 介面，這個介面接收一個 $db 參數，用來動態調用 $db 物件 StudentModel 新增私有屬性：$plugin StudentModel 新增公開方法：setConditionPlugin()，其參數型別為 ConditionPlugin 介面。供外部可以注入插件。 StudentModel-&gt;studentList() 方法中，調用外部注入插件（$this-&gt;plugin）的setWhereCondition() 方法來擴充核心邏輯的行為。 其中，ConditionPlugin 是插件需要實作的介面，實作的內容即為：擴充核心邏輯，以便完成需求。只要類別有實作 ConditionPlugin 介面，都可以透過 setConditionPlugin 函式將插件注入到 StudentModel 中。這樣的作法是利用物件導向 多型 的特性，讓程式碼可以隨著 $plugin 變數運作時的真實物件，會引發不同的動作，達到擴充核心邏輯的效果。 接下來我們將依照 ConditionPlugin 介面的定義，實作各種「學生列表」功能的插件： 2. 實作插件介面，並於注入插件為了縮短範例的長度，此步驟只挑出「尚未繳交 108 學年度腳踏車證費用的學生列表」的需求來講解，其餘的需求則先帶過： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 1. 新增一個類別（插件）並實作 ConditionPlugin 介面：/** *「學生列表」插件：撈取指定學年度與符合付款狀態的學生 */class StudentListPluginThatNotPaidBicyclePassFee implements ConditionPlugin{ private $bicyclePassYear; private $payStatus; public function __construct($bicyclePassYear, $payStatus) { $this-&gt;bicyclePassYear = $bicyclePassYear; $this-&gt;payStatus = $payStatus; } // 2. 將原本放在 `StudentModel-&gt;studentList()` 的邏輯搬移至此 public function setWhereCondition($db) { $db-&gt;leftJoin('bicyclePass', 'students.id = bicyclePass.studentId'); $db-&gt;where('bicyclePass.year', $this-&gt;bicyclePassYear); $db-&gt;where('bicyclePass.payStatus', $this-&gt;payStatus); }}// 3. 修改 StudentController，從 Controller 配置 StudentModel 的擴充插件class StudentController extends Controller{ /** var \\StudentModel **/ private $model; /** 顯示某班級的所有學生 **/ public function studentList($classId) { /** ...省略 */} /** 已完成作業的學生列表 **/ public function studentListByHomeworkStatus(){ /** ...省略 */ } /** 尚未繳交 108 學年度腳踏車證費用的學生列表 **/ public function studentListThatNotPaidBicyclePassFee() { $classId = $this-&gt;input-&gt;get('classId'); $bicyclePassYear = 108; $payStatus = false; $ConditionPlugin = new StudentListPluginThatNotPaidBicyclePassFee($bicyclePassYear, $payStatus); $this-&gt;model-&gt;setConditionPlugin($ConditionPlugin); return $this-&gt;model-&gt;studentList($classId); }} 這個步驟中，我們建立了一個名稱為 StudentListPluginThatNotPaidBicyclePassFee 的插件，這個插件裡面的邏輯，其實就是把原本寫在 StudentModel-&gt;studentList() 的邏輯搬移過來而已。其他的「學生列表」功能也要以此類推，把當初寫在 StudentModel-&gt;studentList() 的邏輯搬移到自己的插件中。這麼一來，就已經把核心邏輯與附加邏輯拆開了。 最後在每個需求的 Controller 層，透過 StudentModel 的公開方法setConditionPlugin() 將插件注入 StudentModel 裡面。StudentModel 在撈取學生時就可以透過被注入的插件來擴充核心邏輯。 3. 每個插件都只負責一個職責上一步驟中，將每個附加邏輯與核心邏輯隔離後，即可產生新的結構： （圖三）中，每個插件都只負責執行一個需求的程式碼；StudentModel-&gt;studentList() 函式則專注於撈取學生列表。兜了這麼大一圈，這才是 單一職責原則 要我們做的事情： 隔離 核心邏輯 與 附加功能邏輯 當使用 核心邏輯 的情境不同時，就應該隔離該使用情境的程式碼 每個類別最多只負責一個情境的程式碼，避免造成耦合，或意圖模糊 單一職責原則，其實是以更高一層的角度在看程式碼。寫程式碼的時候，應該時時刻刻注意當前的程式碼會不會跟 當前需求 不相關的程式碼寫在一起。若有的話表示 核心邏輯 和 附加功能邏輯 可能已經混在一起了，這時就可以考慮導入單一職責原則，隔離 核心邏輯 和 附加邏輯，並且確保每個類別只負責一個需求的程式碼，避免程式碼的耦合越來越深。 所以單一職責的職責到底是什麼？很多人被單一職責原則的名字給混淆了，以為一個類別只可以做一件事情。但事實上「一次只做一件事」是函式層級的原則。 單一職責原則在類別層級中，用來劃分介面和型別的邊界2，將不同意圖、不同使用情境、不同需求、不同修改時機的功能劃分為各自獨立的「職責」，最後由類別來實現這些被獨立的職責。因此當一個職責的需求異動時，也表示只有 負責實現該職責的類別 需要被異動（修改局部化）。 為了讓類別容易被維護，一個類別應該盡可能減少負責的職責，這就是單一職責原則想傳達的概念： 「A class should have only one reason to change.」以一個類別來說，應該只有一個引起它變化的原因。 「only one reason to change」，其實就是在說一個類別應該只負責 一個意圖 或 一個使用情境，也就是上述的「職責」。 這意味著系統功能會由許多小巧且高內聚的類別組成，且每個類別只專注於實現單一的職責。 單一職責做得很好時，每個類別都只有一個唯一的目的。因此需要進行功能修改的時候可以更容易地專注在一個或特定幾個類別。不但加快找查程式碼的速度，也讓系統的修改可以局部化，降低維護系統的困難度。因此在一個高內聚性的系統中，程式碼可讀性及復用的可能性都會提高，儘管程式複雜，但容易被管理。 系列文章： 淺談物件導向 SOLID 原則對工程師的好處與如何影響能力 再談 SOLID 原則，Why SOLID? 物件導向設計原則：單一職責原則，定義、解析與實踐 物件導向設計原則：開放封閉原則，定義、解析與實踐 註腳1.耦合：將許多功能封裝在同一個類別、介面、方法，但這些功能彼此的意圖卻不相同。 ↩2.邊界：明確定義一個類別、函式要實作的功能目標與涉及範圍。 ↩","link":"/blog/solid_srp_definition_and_practices/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","link":"/blog/tags/Clean-Code/"},{"name":"codeigiter3","slug":"codeigiter3","link":"/blog/tags/codeigiter3/"},{"name":"php","slug":"php","link":"/blog/tags/php/"},{"name":"自學技巧","slug":"自學技巧","link":"/blog/tags/%E8%87%AA%E5%AD%B8%E6%8A%80%E5%B7%A7/"},{"name":"重構","slug":"重構","link":"/blog/tags/%E9%87%8D%E6%A7%8B/"},{"name":"SOLID 原則","slug":"SOLID-原則","link":"/blog/tags/SOLID-%E5%8E%9F%E5%89%87/"}],"categories":[{"name":"軟體開發思維","slug":"軟體開發思維","link":"/blog/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E6%80%9D%E7%B6%AD/"},{"name":"重構","slug":"軟體開發思維/重構","link":"/blog/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E6%80%9D%E7%B6%AD/%E9%87%8D%E6%A7%8B/"}]}